{"version":3,"sources":["src/index.tsx","src/menu.tsx","src/menu-container.tsx"],"names":["menu_container_1","$fsx","r","utils_1","typings_1","search","this","state","NativeSelect","Select","getValueOptions","options","props","value","openMenu","blindTextTimeout","setTimeout","setState","blindText","exports","emptyText","Math","min","max","length","rowHeight","menuHeight","labelComponent","selectedIndex","optionComponent","values","some","item","equal","React","createElement","Menu","EmptyOptionItem","label_1","SelectLabel","tslib_1","__decorate","clientRect","menuOverlay","getBoundingClientRect","menuWrapper","window","Number","width","rect","allowRectChange","e","el","onRef","MenuContainer"],"mappings":"yNAAA,MAAAA,EAAAC,EAAAC,EAAA,GACAC,EAAAF,EAAAC,EAAA,iBACA,MAAAE,EAAAH,EAAAC,EAAA,2SACA,MAAAG,OAAAA,GAAAC,KAAAC,giCAAA,06BACA,MAAAC,aAAAA,GAAAC,qrBAAAN,EAAAO,gBAAAC,GAAA,GAAAL,KAAAM,MAAAC,2RAqBIP,KAAAQ,22BAAAR,KAAAS,iBAAAC,WAAA,IAAAV,KAAAW,SAAA,CAAAC,UAAA,KAAA;;;;;;;;;;;;;;;;;;;;;;;q8FADAC,EAQJV,OAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;isBChCA,MAAAJ,OAAAA,EAAAe,UAAAA,EAAAT,QAAAA,GAAAL,KAAAM,8SAAAS,KAAAC,IAAAD,KAAAE,IAAAZ,EAAAa,OAAAC,EAAAA,GAAAnB,KAAAM,MAAAc,YAAA,wYACA,MAAAf,QAAAA,EAAA,GAAAgB,eAAAA,EAAAC,cAAAA,EAAAC,gBAAAA,EAAAJ,UAAAA,EAAApB,OAAAA,GAAAC,KAAAM,8aACAkB,IADAxB,KAAAM,MAAAC,MAAAkB,KAAAC,GAAA7B,EAAA8B,MAAAD,EAAAnB;;iBAa0BqB,EAAAC,cAAAC,EAAAC,gBAAA,KAAAH,EAAAC,cAAAG,EAAAC,YAAA,KAAAL,EAAAC,cAAA,IAAA,KAAAvB,EAAAQ,WAAA,gBAmBlBoB,EAAAC,WAAA,kKAEAD,EAAAC,WAAA,+lBArBRtB,EAAAiB,KAAAA;;;;;;;;;;;;;;;;;;;;;;;;mHCdA,MAAAM,EAAApC,KAAAqC,YAAAC,gLACA,MAAAF,EAAApC,KAAAuC,YAAAD,iJACA,MAAAE,OAAAA,GAAAxC,0dAAAyC,OAAAC,yQACA,MAAAL,YAAAA,EAAAE,YAAAA,GAAAvC,KAAAC,+LAAA,0OAgBI0C,KAAA3C,KAAAC,MAAAoC,yEAGArC,KAAAwC,wZAMAxC,KAAA4C,gBAAAC,gNAAIC,GAAA9C,KAAAM,MAAAyC,8CAIJ/C,KAAAuC,qmBAAI1B,EAyDRmC,cAAAA","sourcesContent":["import { bind, debounce } from 'lodash-decorators';\nimport * as React from 'react';\nimport styled, { css } from 'styled-components';\nimport { Value } from './value';\nimport { Menu } from './menu';\nimport { MenuContainer } from './menu-container';\nimport {\n    isArray,\n    keys,\n    getDocument,\n    getValueOptions,\n    equal,\n    toKey\n} from './utils';\nimport {\n    SelectProps,\n    SelectState,\n    MenuComponentProps,\n    LabelComponentProps,\n    Option\n} from './typings';\nimport './global-stylings';\n\nexport {\n    SelectProps,\n    Menu,\n    MenuComponentProps,\n    LabelComponentProps,\n    Option,\n    keys\n};\n\nexport class Select<T = any> extends React.PureComponent<\n    SelectProps<T>,\n    SelectState\n> {\n    private static Container = styled.div`\n        display: flex;\n        position: relative;\n        cursor: default;\n        width: 100%;\n        box-sizing: border-box;\n        pointer-events: ${(props: { disabled?: boolean }) =>\n            props.disabled ? 'none' : 'auto'};\n        opacity: ${(props: { disabled?: boolean }) =>\n            props.disabled ? 0.75 : 1};\n        user-select: none;\n    `;\n\n    private static NativeSelect = styled.select`\n        display: block;\n        opacity: 0;\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        ${(props: { native?: boolean }) =>\n            props.native\n                ? css`\n                      z-index: 1;\n                  `\n                : css`\n                      pointer-events: none;\n                      z-index: auto;\n                  `};\n    `;\n\n    private nativeSelect: React.RefObject<HTMLSelectElement>;\n    private container: HTMLDivElement | null = null;\n    private blindTextTimeout!: number;\n\n    constructor(props: SelectProps) {\n        super(props);\n\n        this.nativeSelect = React.createRef();\n\n        this.state = {\n            open: false,\n            blindText: ''\n        };\n    }\n\n    private get options(): Option<T>[] {\n        const { search } = this.state;\n        const { creatable, onCreateText } = this.props;\n        let options = this.props.options || [];\n        const showCreate =\n            creatable &&\n            !options.some(option => option.value === (search as any));\n\n        if (search) {\n            options = options.filter(option =>\n                option.label.toLowerCase().includes(search.toLowerCase())\n            );\n        }\n\n        if (showCreate && search) {\n            options = [\n                {\n                    label: onCreateText\n                        ? onCreateText(search)\n                        : `Create \"${search}\"`,\n                    value: search as any,\n                    creatable: true\n                },\n                ...options\n            ];\n        }\n\n        return options;\n    }\n\n    private get document() {\n        return getDocument();\n    }\n\n    private optionIsCreatable(option: Option<T>): boolean {\n        return (\n            this.props.creatable &&\n            option.creatable &&\n            Boolean(this.props.onCreate && this.state.search)\n        );\n    }\n\n    public componentDidUpdate(_, prevState: SelectState): void {\n        if (\n            this.state.blindText &&\n            prevState.blindText !== this.state.blindText\n        ) {\n            this.handleBlindTextUpdate();\n        }\n    }\n\n    public componentWillUnmount(): void {\n        this.removeDocumentListener();\n    }\n\n    public render(): React.ReactNode {\n        const { Container } = Select;\n        const {\n            className,\n            options,\n            creatable,\n            clearable,\n            placeholder,\n            value,\n            disabled,\n            error,\n            menuComponent,\n            labelComponent,\n            optionComponent,\n            valueComponentSingle,\n            valueComponentMulti,\n            arrowComponent,\n            clearComponent,\n            multi,\n            native,\n            emptyText,\n            rowHeight,\n            menuWidth,\n            menuHeight,\n            keepSearchOnBlur\n        } = this.props;\n        const { open, search, selectedIndex, focused } = this.state;\n        const searchable = this.props.searchable || creatable;\n\n        if (this.props.children) {\n            return this.renderChildren();\n        }\n\n        const classNames = [\n            'react-slct',\n            className,\n            open && 'open',\n            error && 'has-error'\n        ].filter(c => Boolean(c));\n\n        return (\n            <Container\n                className={classNames.join(' ')}\n                disabled={disabled}\n                ref={this.onContainerRef as any}\n                data-role={this.props['data-role']}\n                onKeyUp={this.onKeyUp}\n                onKeyDown={this.onKeyDown}\n            >\n                {this.renderNativeSelect()}\n                <Value\n                    clearable={clearable}\n                    searchable={searchable}\n                    open={open}\n                    disabled={disabled}\n                    multi={multi}\n                    mobile={native}\n                    focused={focused}\n                    options={options}\n                    placeholder={placeholder}\n                    error={error}\n                    value={value}\n                    search={search}\n                    keepSearchOnBlur={keepSearchOnBlur}\n                    labelComponent={labelComponent}\n                    valueComponentSingle={valueComponentSingle}\n                    valueComponentMulti={valueComponentMulti}\n                    arrowComponent={arrowComponent}\n                    clearComponent={clearComponent}\n                    onClear={this.onClear}\n                    onClick={this.toggleMenu}\n                    onSearch={this.onSearch}\n                    onSearchFocus={this.onSearchFocus}\n                    onSearchBlur={this.onSearchBlur}\n                    onOptionRemove={this.onOptionRemove}\n                />\n                <Menu\n                    open={open}\n                    options={this.options}\n                    value={value}\n                    multi={multi}\n                    error={error}\n                    search={search}\n                    selectedIndex={selectedIndex}\n                    menuComponent={menuComponent}\n                    labelComponent={labelComponent}\n                    optionComponent={optionComponent}\n                    emptyText={emptyText}\n                    rowHeight={rowHeight}\n                    menuWidth={menuWidth}\n                    menuHeight={menuHeight}\n                    onSelect={this.onOptionSelect}\n                />\n            </Container>\n        );\n    }\n\n    private renderNativeSelect(): React.ReactNode {\n        const { NativeSelect } = Select;\n        const { native, placeholder, multi, disabled } = this.props;\n        const dataRole = this.props['data-role']\n            ? `select-${this.props['data-role']}`\n            : undefined;\n        const clearable = this.props.clearable && native;\n        const value = isArray(this.props.value)\n            ? this.props.value.map(this.findOptionIndex)\n            : this.findOptionIndex(this.props.value || '');\n\n        return (\n            <NativeSelect\n                ref={this.nativeSelect as any}\n                multiple={multi}\n                value={value}\n                disabled={disabled}\n                native={native}\n                tabIndex={-1}\n                data-role={dataRole}\n                onChange={this.onChangeNativeSelect}\n            >\n                <option value=\"\" disabled={!clearable}>\n                    {placeholder}\n                </option>\n                {this.options.map((option, i) => (\n                    <option\n                        key={toKey(option.value)}\n                        value={`${i}`}\n                        disabled={option.disabled}\n                    >\n                        {option.label}\n                    </option>\n                ))}\n            </NativeSelect>\n        );\n    }\n\n    private renderChildren(): React.ReactNode {\n        const { options, placeholder, multi, children } = this.props;\n        const { open, search } = this.state;\n        const valueOptions = getValueOptions(options || [], this.props.value);\n        const value: T | T[] | undefined = !multi\n            ? this.props.value\n            : valueOptions.map(option => option.value);\n        const showPlaceholder =\n            !search &&\n            (isArray(value)\n                ? value.length === 0\n                : value === undefined || value === null);\n\n        if (!children) {\n            return null;\n        }\n\n        return children({\n            options: this.options,\n            open,\n            value,\n            MenuContainer,\n            placeholder: showPlaceholder ? placeholder : undefined,\n            onToggle: () => this.toggleMenu(),\n            onRef: ref => (this.container = ref)\n        });\n    }\n\n    @bind\n    private toggleMenu(): void {\n        const open = !this.state.open;\n\n        if (open) {\n            this.openMenu();\n        } else {\n            this.closeMenu();\n        }\n    }\n\n    @debounce(0)\n    private openMenu(): void {\n        const selectedIndex = this.options.findIndex(option =>\n            equal(option.value, this.props.value)\n        );\n        const keepSearchOnBlur =\n            this.props.keepSearchOnBlur && !this.props.value;\n\n        this.setState(\n            {\n                open: true,\n                search: keepSearchOnBlur ? this.state.search : undefined,\n                selectedIndex\n            },\n            () => {\n                if (this.props.onOpen) {\n                    this.props.onOpen();\n                }\n\n                this.addDocumentListener();\n            }\n        );\n    }\n\n    @debounce(0)\n    private closeMenu(callback = () => {}): void {\n        const keepSearchOnBlur =\n            this.props.keepSearchOnBlur && !this.props.value;\n\n        this.removeDocumentListener();\n        this.setState(\n            {\n                open: false,\n                search: keepSearchOnBlur ? this.state.search : undefined,\n                selectedIndex: undefined\n            },\n            () => {\n                if (this.props.onClose) {\n                    this.props.onClose();\n                }\n\n                callback();\n            }\n        );\n    }\n\n    private createOption(value: string, cb?: () => void): void {\n        const { onCreate } = this.props;\n\n        if (onCreate) {\n            this.closeMenu(() => {\n                onCreate(value);\n\n                if (cb) {\n                    cb();\n                }\n            });\n        }\n    }\n\n    private addDocumentListener(): void {\n        this.removeDocumentListener();\n\n        if (this.document) {\n            this.document.addEventListener('click', this.onDocumentClick);\n        }\n    }\n\n    private removeDocumentListener(): void {\n        if (this.document) {\n            this.document.removeEventListener('click', this.onDocumentClick);\n        }\n    }\n\n    @bind\n    private cleanBlindText(): void {\n        this.blindTextTimeout = setTimeout(\n            () => this.setState({ blindText: '' }),\n            700\n        );\n    }\n\n    @bind\n    private findOptionIndex(val: any) {\n        let index = this.options.findIndex(option => option.value === val);\n\n        if (index === -1) {\n            if (typeof val === 'object') {\n                index = this.options.findIndex(option => {\n                    if (typeof option.value === 'object') {\n                        return (\n                            JSON.stringify(option.value) === JSON.stringify(val)\n                        );\n                    }\n\n                    return false;\n                });\n            }\n\n            if (index === -1) {\n                return '';\n            }\n        }\n\n        return String(index);\n    }\n\n    @bind\n    private onChangeNativeSelect(\n        e: React.SyntheticEvent<HTMLSelectElement>\n    ): void {\n        const { onChange, multi } = this.props;\n        const { currentTarget } = e;\n\n        if (onChange) {\n            if (currentTarget.value === '') {\n                this.onClear();\n            } else {\n                const values = Array.from(currentTarget.selectedOptions).map(\n                    htmlOption => this.options[htmlOption.index - 1].value\n                );\n\n                if (multi) {\n                    onChange(values as any);\n                } else {\n                    onChange(values[0] as any);\n                }\n            }\n        }\n    }\n\n    @bind\n    private onSearchFocus(): void {\n        const { open, focused } = this.state;\n\n        if (!open && !focused && !this.props.native) {\n            this.openMenu();\n        }\n\n        this.setState({ focused: true });\n    }\n\n    @bind\n    private onSearchBlur(): void {\n        this.setState({ focused: false });\n    }\n\n    @bind\n    private onOptionSelect(value: any | any[], option?: Option<T>): void {\n        const { current } = this.nativeSelect;\n        const { onChange, creatable } = this.props;\n        let optionWasCreated = false;\n\n        const selectOnNative = () => {\n            if (current) {\n                current.value = isArray(value)\n                    ? (value.map(this.findOptionIndex) as any)\n                    : this.findOptionIndex(value);\n            }\n\n            this.setState({ focused: true }, () =>\n                this.closeMenu(() => onChange && onChange(value, option))\n            );\n        };\n\n        if (creatable) {\n            const createValue = (val: any) => {\n                const option = this.options.find(\n                    option =>\n                        this.optionIsCreatable(option) && option.value === val\n                );\n\n                if (option) {\n                    optionWasCreated = true;\n                    this.createOption(option.value as any, selectOnNative);\n                }\n            };\n\n            if (isArray(value)) {\n                value.map(createValue);\n            } else {\n                createValue(value);\n            }\n        }\n\n        if (!optionWasCreated) {\n            selectOnNative();\n        }\n    }\n\n    @bind\n    private onOptionRemove(value: any): void {\n        if (isArray(this.props.value)) {\n            const values = this.props.value.filter(val => !equal(val, value));\n\n            this.onOptionSelect(values);\n        }\n    }\n\n    @bind\n    private onClear(): void {\n        this.onOptionSelect(this.props.multi ? [] : undefined);\n    }\n\n    @bind\n    private onSearch(search: string): void {\n        this.setState({ search }, () => {\n            if (this.options.length === 1 || (this.props.creatable && search)) {\n                this.setState({ selectedIndex: 0 });\n            } else {\n                this.setState({ selectedIndex: undefined });\n            }\n\n            if (this.props.onSearch) {\n                this.props.onSearch(search);\n            }\n        });\n    }\n\n    @bind\n    private onDocumentClick(e): void {\n        const { target } = e;\n\n        if (target.closest('.react-slct-menu')) {\n            return;\n        }\n\n        if (this.container && !this.container.contains(target)) {\n            this.closeMenu();\n        }\n    }\n\n    @bind\n    private onKeyDown({ keyCode }: React.KeyboardEvent): void {\n        const { searchable, creatable } = this.props;\n\n        switch (keyCode) {\n            case keys.TAB:\n                if (this.state.open) {\n                    this.closeMenu();\n                }\n                break;\n        }\n\n        if (!searchable && !creatable) {\n            this.handleBlindText(keyCode);\n        }\n    }\n\n    @bind\n    private onKeyUp({ keyCode }: React.KeyboardEvent): void {\n        const { search, open } = this.state;\n        const { value } = this.props;\n        let selectedIndex = this.state.selectedIndex;\n\n        switch (keyCode) {\n            case keys.ARROW_UP:\n                if (open) {\n                    if (selectedIndex !== undefined) {\n                        selectedIndex = selectedIndex - 1;\n\n                        if (selectedIndex < 0) {\n                            selectedIndex = this.options.length - 1;\n                        }\n                    }\n\n                    this.setState({ selectedIndex });\n                } else {\n                    this.openMenu();\n                }\n                break;\n            case keys.ARROW_DOWN:\n                if (open) {\n                    if (\n                        selectedIndex === undefined ||\n                        selectedIndex === this.options.length - 1\n                    ) {\n                        selectedIndex = 0;\n                    } else {\n                        selectedIndex = selectedIndex + 1;\n                    }\n\n                    this.setState({ selectedIndex });\n                } else {\n                    this.openMenu();\n                }\n                break;\n            case keys.ENTER:\n                if (\n                    this.state.selectedIndex === 0 &&\n                    this.optionIsCreatable(this.options[0])\n                ) {\n                    this.createOption(search!);\n                } else if (\n                    selectedIndex !== undefined &&\n                    this.options[selectedIndex]\n                ) {\n                    const option = this.options[selectedIndex];\n                    const newValue = option.value;\n\n                    this.onOptionSelect(\n                        isArray(value) ? [...value, newValue] : newValue,\n                        option\n                    );\n                }\n                break;\n            case keys.ESC:\n                if (open) {\n                    this.closeMenu();\n                }\n                break;\n        }\n    }\n\n    private handleBlindText(keyCode: number): void {\n        const { blindText } = this.state;\n\n        if (keyCode === keys.BACKSPACE && blindText.length) {\n            clearTimeout(this.blindTextTimeout);\n\n            this.setState(\n                {\n                    blindText: blindText.slice(0, blindText.length - 1)\n                },\n                this.cleanBlindText\n            );\n        } else if (keyCode === keys.SPACE) {\n            clearTimeout(this.blindTextTimeout);\n\n            this.setState(\n                {\n                    blindText: blindText + ' '\n                },\n                this.cleanBlindText\n            );\n        } else {\n            const key = String.fromCodePoint(keyCode);\n\n            if (/\\w/.test(key)) {\n                clearTimeout(this.blindTextTimeout);\n\n                this.setState(\n                    {\n                        blindText: blindText + key\n                    },\n                    this.cleanBlindText\n                );\n            }\n        }\n    }\n\n    @bind\n    private onContainerRef(el: HTMLDivElement | null): void {\n        this.container = el;\n    }\n\n    private handleBlindTextUpdate(): void {\n        const { open, blindText } = this.state;\n        const { multi } = this.props;\n\n        if (open) {\n            const selectedIndex = this.options.findIndex(option =>\n                option.label.toLowerCase().startsWith(blindText.toLowerCase())\n            );\n\n            if (selectedIndex >= 0) {\n                this.setState({ selectedIndex });\n            }\n        } else if (!multi) {\n            if (blindText) {\n                const option = this.options.find(option =>\n                    option.label\n                        .toLowerCase()\n                        .startsWith(blindText.toLowerCase())\n                );\n\n                if (option) {\n                    this.onOptionSelect(option.value, option);\n                }\n            } else {\n                this.onOptionSelect(undefined);\n            }\n        }\n    }\n}\n","import { bind } from 'lodash-decorators';\nimport * as React from 'react';\nimport { List } from 'react-virtualized/dist/commonjs/List';\nimport styled from 'styled-components';\nimport { SelectLabel } from './label';\nimport { MenuContainer } from './menu-container';\nimport { OptionComponent } from './option';\nimport { MenuComponentProps, Option, Rect } from './typings';\nimport { equal, isArray } from './utils';\n\ninterface MenuComponentState {\n    rect?: Rect;\n}\n\nexport class Menu extends React.PureComponent<\n    MenuComponentProps,\n    MenuComponentState\n> {\n    private static EmptyOptionItem = styled(OptionComponent.OptionItem)`\n        height: 100%;\n    `;\n\n    private static Empty = (props: { emptyText?: string }) => (\n        <Menu.EmptyOptionItem>\n            <SelectLabel>\n                <i>{props.emptyText || 'No results'}</i>\n            </SelectLabel>\n        </Menu.EmptyOptionItem>\n    );\n\n    private list: React.RefObject<List>;\n\n    constructor(props) {\n        super(props);\n\n        this.state = {};\n        this.list = React.createRef();\n    }\n\n    public componentDidUpdate(prevProps: MenuComponentProps): void {\n        const { search, emptyText, options } = this.props;\n        const { current: list } = this.list;\n\n        if (list) {\n            if (\n                search !== prevProps.search ||\n                emptyText !== prevProps.emptyText ||\n                options !== prevProps.options\n            ) {\n                list.forceUpdateGrid();\n            }\n        }\n    }\n\n    public render(): React.ReactNode {\n        const { open, options = [], selectedIndex, error } = this.props;\n        const { rect } = this.state;\n        const MenuContent = this.props.menuComponent;\n        const rowHeight = this.props.rowHeight || 32;\n        const width =\n            this.props.menuWidth ||\n            (rect && rect.width !== 'auto' ? rect.width : 0);\n        const height = Math.min(\n            Math.max(options.length * rowHeight, rowHeight),\n            this.props.menuHeight || 185\n        );\n\n        return open ? (\n            <MenuContainer\n                error={error}\n                menuWidth={width}\n                menuHeight={height}\n                onRect={this.onRect}\n            >\n                {MenuContent ? (\n                    <MenuContent {...this.props} />\n                ) : (\n                    <List\n                        className=\"react-slct-menu-list\"\n                        ref={this.list}\n                        width={width}\n                        height={height}\n                        rowHeight={rowHeight}\n                        rowCount={options.length}\n                        rowRenderer={this.rowRenderer}\n                        scrollToIndex={selectedIndex}\n                        noRowsRenderer={this.emptyRenderer}\n                    />\n                )}\n            </MenuContainer>\n        ) : null;\n    }\n\n    @bind\n    private rowRenderer({ key, index, style }) {\n        const {\n            options = [],\n            labelComponent,\n            selectedIndex,\n            optionComponent,\n            rowHeight,\n            search\n        } = this.props;\n        const option = options[index];\n        const currentValue = isArray(this.props.value)\n            ? this.props.value\n            : [this.props.value];\n        const Component = optionComponent || OptionComponent;\n\n        return (\n            <div key={key} style={style}>\n                <Component\n                    option={option}\n                    labelComponent={labelComponent}\n                    height={rowHeight}\n                    active={currentValue.some(val => equal(val, option.value))}\n                    selected={selectedIndex === index}\n                    search={search}\n                    onSelect={this.onSelect}\n                />\n            </div>\n        );\n    }\n\n    @bind\n    private emptyRenderer() {\n        const { Empty } = Menu;\n\n        return <Empty emptyText={this.props.emptyText} />;\n    }\n\n    @bind\n    private onSelect(value: any, option: Option): void {\n        if (isArray(this.props.value)) {\n            const found = this.props.value.some(item => equal(item, value));\n\n            let values;\n\n            if (found) {\n                values = this.props.value.filter(item => !equal(item, value));\n            } else {\n                values = Array.from(new Set([...this.props.value, value]));\n            }\n\n            this.props.onSelect(values, option);\n        } else {\n            this.props.onSelect(value, option);\n        }\n    }\n\n    @bind\n    private onRect(rect?: Rect): void {\n        this.setState({ rect });\n    }\n}\n\nexport interface MenuContainerState {\n    rect?: Rect;\n}\n","import { bind, debounce } from 'lodash-decorators';\nimport * as React from 'react';\nimport { createPortal } from 'react-dom';\nimport styled from 'styled-components';\nimport { MenuContainerProps, Rect } from './typings';\nimport { getDocument, getWindow, getWindowInnerHeight } from './utils';\n\nexport interface MenuContainerState {\n    menuOverlay?: Rect;\n    menuWrapper?: Rect;\n}\n\ninterface MenuWrapperProps {\n    rect?: Rect;\n    menuHeight?: MenuContainerProps['menuHeight'];\n    error?: boolean;\n}\n\nfunction menuPosition({\n    rect,\n    menuHeight = 186\n}: MenuWrapperProps): 'top' | 'bottom' {\n    if (!rect) {\n        return 'bottom';\n    }\n\n    const { height } = rect;\n\n    if (height === 'auto' || menuHeight === 'auto') {\n        return 'bottom';\n    }\n\n    if (rect.top + height + menuHeight <= getWindowInnerHeight()) {\n        return 'bottom';\n    }\n\n    return 'top';\n}\n\nfunction getContainerTop(props: MenuWrapperProps): number {\n    const { rect } = props;\n\n    if (!rect) {\n        return 0;\n    }\n\n    const menuHeight = (props.menuHeight !== 'auto' && props.menuHeight) || 186;\n    const height = rect.height === 'auto' ? 32 : rect.height;\n\n    switch (menuPosition(props)) {\n        case 'top':\n            return rect.top - menuHeight + 1;\n        case 'bottom':\n            return rect.top + height - 1;\n    }\n}\n\nconst MenuOverlay = styled.div`\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    pointer-events: none;\n`;\n\nconst MenuWrapper = styled.div`\n    position: fixed;\n    z-index: 9999;\n    background: #fff;\n    box-sizing: border-box;\n    box-shadow: ${(props: MenuWrapperProps) =>\n        menuPosition(props) === 'bottom'\n            ? '0 2px 5px rgba(0, 0, 0, 0.1)'\n            : '0 -2px 5px rgba(0, 0, 0, 0.1)'};\n\n    .ReactVirtualized__List {\n        border-width: 1px;\n        border-style: solid;\n        border-color: ${(props: MenuWrapperProps) =>\n            props.error ? 'var(--react-slct-error-color)' : '#ccc'};\n        background-color: #fff;\n\n        &:focus {\n            outline: none;\n        }\n    }\n`;\n\nexport class MenuContainer extends React.PureComponent<\n    MenuContainerProps,\n    MenuContainerState\n> {\n    private menuOverlay?: HTMLDivElement | null;\n    private menuWrapper?: HTMLDivElement | null;\n\n    private get menuOverlayRect(): Rect | undefined {\n        if (this.menuOverlay) {\n            const clientRect = this.menuOverlay.getBoundingClientRect();\n\n            return {\n                left: Math.round(clientRect.left),\n                top: Math.round(clientRect.top),\n                width: Math.round(clientRect.width),\n                height: Math.round(clientRect.height)\n            };\n        }\n\n        return undefined;\n    }\n\n    private get menuWrapperRect(): Rect | undefined {\n        if (this.menuWrapper) {\n            const clientRect = this.menuWrapper.getBoundingClientRect();\n\n            return {\n                left: Math.round(clientRect.left),\n                top: Math.round(clientRect.top),\n                width: Math.round(clientRect.width),\n                height: Math.round(clientRect.height)\n            };\n        }\n\n        return undefined;\n    }\n\n    private get style(): Rect {\n        const { window } = this;\n        const { menuLeft, menuTop, menuWidth } = this.props;\n        const { menuOverlay, menuWrapper } = this.state;\n        const menuHeight =\n            this.props.menuHeight ||\n            (menuWrapper ? menuWrapper.height : 'auto');\n        let width = menuWidth || (menuOverlay ? menuOverlay.width : 'auto');\n        const height =\n            menuHeight || (menuWrapper ? menuWrapper.height : 'auto');\n        const top =\n            menuTop !== undefined\n                ? menuTop\n                : getContainerTop({\n                      rect: menuOverlay,\n                      menuHeight: height\n                  });\n        let left =\n            menuLeft !== undefined\n                ? menuLeft\n                : menuOverlay\n                ? menuOverlay.left\n                : 0;\n\n        if (window) {\n            const numWidth = Number(width);\n\n            if (numWidth > window.innerWidth) {\n                width = window.innerWidth - 20;\n            }\n\n            if (left + numWidth > window.innerWidth) {\n                left = Math.max(10, window.innerWidth - numWidth - 20);\n            }\n        }\n\n        return { top, left, width, height };\n    }\n\n    private get window() {\n        return getWindow();\n    }\n\n    private get document() {\n        return getDocument();\n    }\n\n    constructor(props: MenuContainerProps) {\n        super(props);\n\n        this.state = {};\n    }\n\n    public componentDidMount(): void {\n        this.addListener();\n    }\n\n    public componentDidUpdate(_: any, prevState: MenuContainerState): void {\n        const { menuOverlay, menuWrapper } = this.state;\n\n        if (this.props.onRect) {\n            if (\n                prevState.menuOverlay !== menuOverlay ||\n                prevState.menuWrapper !== menuWrapper\n            ) {\n                this.props.onRect(menuOverlay, menuWrapper);\n            }\n        }\n    }\n\n    public componentWillUnmount(): void {\n        this.removeListener();\n    }\n\n    public render(): React.ReactNode {\n        const { error, onClick, children } = this.props;\n        const className = ['react-slct-menu', this.props.className]\n            .filter(c => c)\n            .join(' ');\n\n        return (\n            <MenuOverlay ref={this.onMenuOverlay}>\n                {this.document\n                    ? createPortal(\n                          <MenuWrapper\n                              data-role=\"menu\"\n                              className={className}\n                              error={error}\n                              ref={this.onMenuWrapper}\n                              onClick={onClick}\n                              rect={this.state.menuOverlay}\n                              style={this.style}\n                          >\n                              {children}\n                          </MenuWrapper>,\n                          this.document.body\n                      )\n                    : null}\n            </MenuOverlay>\n        );\n    }\n\n    private addListener(): void {\n        if (this.window) {\n            this.window.addEventListener('scroll', this.onViewportChange, true);\n            this.window.addEventListener('resize', this.onViewportChange, true);\n        }\n    }\n\n    private removeListener(): void {\n        if (this.window) {\n            this.window.removeEventListener(\n                'resize',\n                this.onViewportChange,\n                true\n            );\n            this.window.removeEventListener(\n                'scroll',\n                this.onViewportChange,\n                true\n            );\n        }\n    }\n\n    private allowRectChange(e): boolean {\n        if (e.target.closest && !e.target.closest('.react-slct-menu')) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @bind\n    private onViewportChange(e): void {\n        if (this.allowRectChange(e)) {\n            this.setState({\n                menuOverlay: this.menuOverlayRect,\n                menuWrapper: this.menuWrapperRect\n            });\n        }\n    }\n\n    @bind\n    private onMenuOverlay(el: HTMLDivElement | null): void {\n        this.menuOverlay = el;\n\n        if (this.menuOverlay) {\n            this.setState({\n                menuOverlay: this.menuOverlayRect\n            });\n        }\n    }\n\n    @bind\n    @debounce(16)\n    private onMenuWrapper(el: HTMLDivElement | null): void {\n        if (el && this.props.onRef) {\n            this.props.onRef(el);\n        }\n\n        this.menuWrapper = el;\n\n        if (this.menuWrapper) {\n            this.setState({\n                menuWrapper: this.menuWrapperRect\n            });\n        }\n    }\n}\n"]}